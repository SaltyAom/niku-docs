# Introduction
Creating UI in Flutter is easy. Its declarative enables developers to control every detail and outcome of how it should be.

To create styling in Flutter, developers have to describe every detail to Widget.
It's like low-level programming UI, having to adapt between property is hard when some are more complex than others, for instance, MaterialStateProperty.

When the codebase gets more complex, the syntax of Flutter itself is too verbose, nested than it should be, result being hard to maintain mostly known as "Nested Hell".

Niku helps to solve the problem by providing a toolkit to style widgets with property builders.
To provide a smoother, shorter yet, more straightforward and maintainable way to compose styling in Flutter.

## Traditional Flutter

For example, with traditional Flutter, adding padding to the text would add an unnecessary nest as the following:
```dart
Padding(
  padding: EdgeInsets.all(20),
  child: Text(
    "Hello World",
    style: const TextStyle(
      color: Colors.blue,
      fontSize: 21,
    ),
  ),
);
```

In a real-world app, composing the layout becomes complex quickly as it becomes more and more nested means it's harder to read and maintain.

Niku eliminates the nested hell problem of Flutter, by providing encapsulated property instead of being nested in the same way like SwiftUI did.

## Niku
Let's rewrite the upper code with Niku:
```dart
import 'package:niku/niku.dart'; // <--- Import Niku library

NikuText("Hello World")
  .color(Colors.blue)
  .fontSize(21)
  .niku()       // <--- Compose Parent Widget
  .p(20)
```

As you might guess the code, instead of reading inside-out of traditional Flutter, Niku provides top-to-bottom to describe the styling, make it more predictable and straightforward.

Using property builder means you can style any widget even if it were 3rd party widget.

Niku can get along with any codebase and still works.